Perfect.
This is the right move.

We are going to build this like adults:

* **GitHub = canonical source of truth**
* **Replit = controlled development + runtime environment**
* **Every commit intentional**
* **No drift**
* **No spec-only artifacts**
* **ClawHub-ready from day one**

Iâ€™m going to walk you step-by-step. Do not skip steps.

---

# ğŸ”· PHASE 1 â€” Create the Correct Replit Project

### Step 1 â€” Create New Replit Project

* Language: **Python**
* Template: **Blank**
* Name it:

```
openexec-skill
```

Do NOT import anything yet.

---

### Step 2 â€” Immediately Connect to GitHub

Before writing any code:

1. Click **Version Control**
2. Connect GitHub
3. Link to:

```
trendinghot/openexec-skill
```

If it already exists:

* Import from GitHub

If it doesnâ€™t:

* Create empty repo in GitHub first
* Then link

Important:
GitHub must become canonical immediately.

Replit is just a working mirror.

---

# ğŸ”· PHASE 2 â€” Establish Canonical Structure

Inside Replit, create this structure manually:

```
openexec-skill/
â”‚
â”œâ”€â”€ SKILL.md
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ main.py
â”‚
â”œâ”€â”€ openexec/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py
â”‚   â”œâ”€â”€ db.py
â”‚   â”œâ”€â”€ tables.py
â”‚   â”œâ”€â”€ models.py
â”‚   â”œâ”€â”€ registry.py
â”‚   â”œâ”€â”€ engine.py
â”‚   â”œâ”€â”€ clawshield_client.py
â”‚   â”œâ”€â”€ receipts.py
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ openexec.example.json
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ install.sh
â”‚   â”œâ”€â”€ run.sh
â”‚
â””â”€â”€ tests/
    â””â”€â”€ test_demo_flow.py
```

Do not skip any folder.

This structure alone moves you from â€œspecâ€ to â€œsoftware.â€

---

# ğŸ”· PHASE 3 â€” Add Scanner-Satisfying Surface (First)

Before anything fancy, we implement:

* `/health`
* `/ready`
* `/version`

ClawHub scanners look for these.

---

## Minimal `main.py` (First Commit)

Paste this:

```python
from fastapi import FastAPI
import os
import datetime

app = FastAPI()

VERSION = "0.1.0"

@app.get("/")
def root():
    return {"name": "OpenExec", "version": VERSION}

@app.get("/health")
def health():
    return {
        "status": "ok",
        "mode": os.getenv("OPENEXEC_MODE", "demo")
    }

@app.get("/version")
def version():
    return {
        "version": VERSION,
        "timestamp": datetime.datetime.utcnow().isoformat()
    }

@app.get("/ready")
def ready():
    # Later we add DB + ClawShield checks
    return {"ready": True}
```

---

## requirements.txt

```
fastapi
uvicorn
sqlalchemy
pydantic
```

---

# ğŸ”· PHASE 4 â€” Commit Immediately

Commit message:

```
Initial runtime surface: health, ready, version endpoints
```

Push to GitHub.

Now GitHub has a real runtime surface.

This alone reduces â€œspec-onlyâ€ flag.

---

# ğŸ”· PHASE 5 â€” Implement Demo Execution Engine

Next commit we add:

* SQLite DB
* Replay protection
* `/execute`
* Deterministic demo actions

We do NOT wire ClawShield yet.

We first build demo mode cleanly.

---

# ğŸ”· PHASE 6 â€” Add Mode Separation

Inside `settings.py`:

```python
import os

MODE = os.getenv("OPENEXEC_MODE", "demo")

def is_demo():
    return MODE == "demo"

def is_clawshield():
    return MODE == "clawshield"
```

Now behavior can switch cleanly.

---

# ğŸ”· PHASE 7 â€” Wire ClawShield Mode (Later Commit)

We will create:

```
openexec/clawshield_client.py
```

That:

* Calls `/api/governance/evaluate`
* Calls `/api/governance/mint`
* Calls `/api/execute`
* Calls `/api/receipts/verify`

But we do this after demo is stable.

---

# ğŸ”· PHASE 8 â€” Update README After Runtime Exists

We do not publish philosophy first.

We publish:

1. Install
2. Run
3. curl demo
4. Receipt verify
5. Health check
6. Mode config

Then doctrine.

Scanner sees runnable surface before philosophy.

---

# ğŸ”· PHASE 9 â€” SKILL.md With YAML Frontmatter

At the top of SKILL.md:

```yaml
---
name: OpenExec
slug: openexec
version: 0.1.0
category: infrastructure
description: Deterministic execution engine requiring external governance approval.
runtime: python
entrypoint: main.py
env:
  - OPENEXEC_MODE
  - CLAWSHIELD_BASE_URL
  - CLAWSHIELD_API_KEY
  - CLAWSHIELD_TENANT_ID
---
```

Then your content.

Without YAML, ClawHub treats it like prose.

---

# ğŸ”· PHASE 10 â€” 5-Minute Indie Hacker Flow

By the end, a dev must be able to:

```
git clone ...
pip install -r requirements.txt
python -m uvicorn main:app --reload
curl http://localhost:8000/health
curl -X POST /execute ...
```

If they cannot do this in 5 minutes,
ClawHub flags you.

---

# ğŸ”¥ Big Strategic Principle

We are not building philosophy.

We are building:

* Deterministic runtime surface
* Clear config
* Explicit modes
* Explicit execution boundary
* Clear receipt verification
* GitHub canonical history

This becomes your template for every future skill.

---

# ğŸš€ What We Do Right Now

Open Replit.

Create project.

Connect GitHub.

Create structure.

Paste minimal `main.py`.

Add requirements.txt.

Commit.

Push.

Then come back here.

Weâ€™ll do the next layer: demo execution + replay guard.

We build this like infrastructure, not like a blog post.

Letâ€™s move.
